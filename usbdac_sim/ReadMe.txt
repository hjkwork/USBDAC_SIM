========================================================================
    控制台应用程序：usbdac_sim 项目概述
========================================================================

应用程序向导已为您创建了此 usbdac_sim 应用程序。

本文件概要介绍组成 usbdac_sim 应用程序的
的每个文件的内容。


usbdac_sim.vcproj
    这是使用应用程序向导生成的 VC++ 项目的主项目文件，
    其中包含生成该文件的 Visual C++ 的版本信息，以及有关使用应用程序向导选择的平台、配置和项目功能的信息。

usbdac_sim.cpp
    这是主应用程序源文件。

/////////////////////////////////////////////////////////////////////////////
其他标准文件：

StdAfx.h, StdAfx.cpp
    这些文件用于生成名为 usbdac_sim.pch 的预编译头 (PCH) 文件和名为 StdAfx.obj 的预编译类型文件。

/////////////////////////////////////////////////////////////////////////////
其他注释：

应用程序向导使用“TODO:”注释来指示应添加或自定义的源代码部分。

/////////////////////////////////////////////////////////////////////////////
//项目功能
为了设计性能优异的库文件用于连接LABVIEW，需要设计一个动态连接库，本程序则是为实现这个库文件而做的测试和前期模拟工作。
需求：
1.建立一个波形发生器，启动后，可同时输出1~n个波形数据。（用不同函数模拟，波的峰值范围从0到1。）
2.建立一个接口，控制USB、DAC等硬件设备，并接收波形发生器的数据，经处理后发送给USB设备。接口有2个缓冲区in_buf（队列）和out_buf，缓冲区大小为n*len，len为一个波形一次的缓冲长度，且len为DAC_BIT的整数倍。将数据做如下处理：
	1）接收波形发生器的n组数据放在in_buf中，
	2）对x个数据转置后存入out_buf.
3.建立一个模拟USB设备，给接收器发送OPEN命令后，当接收器准备就绪，返回成功FLAG，如果out_buf可用并是满的，可以从缓0冲区读数据，并输出到DAC。
4.建立一个DAC和功放设备，用于接收USB发送来的数据并控制输出大小。当收到on_dac后，dac等待dac_delay ms后开始工作，读取USB_GPIF_OUT_COUNT个口的串行数据后，转为模拟信号发出到USB_GPIF_OUT_COUNT个输出通道。
5.建立一个示波器，接收USB_GPIF_OUT_COUNT个模拟信号并显示。


处理后的数据作为队列元素，push入队列，
只要队列不满，就可以push，
若队列满，执行pop，元素送入固定缓存区。并报告向usb发送时有丢失数据
如果队列不为空，pop队列元素到usb设备，即发送队头元素后，删除队头
若队列为空，usb发送固定缓存区的元素数据。 
//
其他的方案
/**********************************2020.03.23************************************/
系统包括了信号发生器、数据传输接口、USB设备
其中，信号发生器可以设计为信号设置类、信号类
数据传输接口可以设计、数据缓冲队列接口类和数据处理类
usb设备可设计USB设备类和usb数据传输类
0.数据定义类
定义需要使用的数据和结构等
1.信号类

2.接口类
设置输入和输出的缓冲队列，包括队列元素类型和队列长度；
输入接口；
输出接口；
数据处理接口,导入数据处理类的处理方法
3.数据处理类
处理数据，
4.usb设备类
用于获取usb设备的信息，包括设备名称、端点信息等
可设置需要使用的usb设备、传输方式、端点等
/*************2020.03.25**重构需求*************************/
1.主程序中，可以设定缓冲队列的长度即输入和输出队列的长度inlen和outlen，当输出队列长度为0时，即只用输入队列，当输入队列长度为0，即只用输出队列
队列采用循环队列形式
2.接口提供输入的入口地址和出口地址，地址分别为输入和输出缓冲区（inbuf和outbuf）的起始地址
入口的类型为输入节点类型，出口的类型为输出节点类型
3.接口中，一旦节点入队，入口地址即转至
/**********************2020.03.27********************/
**循环队列Ringbufcpp的使用（不用interfacofusb类）
1.RingBufCpp维护一个循环数组队列
2.数据传入时可以先获取队列的头节点地址，用getHead获取
3.向头节点填满数据后，队列非满时进行add入队操作，此时头节点的数据即为输入节点的数据
4.条件符合时出队（一般队列非空，执行pull）,出队会将尾节点拷贝到出队的地址
5.处理出队的数据即可

**其他功能需求
1.
**导入cyusb库
1.项目属性，c++常规中，附加包含目录，添加：{安装目录}\Cypress\EZ-USB FX3 SDK\1.3\library\cpp\inc
2.链接器中，输入，附加依赖项，添加：
“{安装目录}\Cypress\EZ-USB FX3 SDK\1.3\library\cpp\lib\x86\CyAPI.lib
setupapi.lib
User32.lib
legacy_stdio_definitions.lib”
vs2017中，需要编译的时候要用到的链接库
**usb的队列传输说明：
1.数据入队是填充一个输入节点，这个节点中数据的大小是一次要处理的数据最小字节数。
2.数据处理完后会入队，此时填充一个输出节点，该节点大小要是输入数据处理后数据大小的整数倍，而且一般也为usb最大传输帧的整数倍
即：outNodeSize = f_sise(inNodeSize)*n=MaxPktSize*m (m,n为正整数)
/**********************2020.03.28********************/
1.思考业务流程，重新组织文件和类的结构（撰写文档）
2.usb设备类和usb传输类的对接和重组（usb设备类单独成类，但是usb传输可以考虑与线程程序合并）
3.单独测试usb设备类和labview的连接，如果没有usb设备类，labview的visa工具是否可以直接使用？
4
/*****************0404***************/
usb设备的c++操作
1 新建usb设备
2 获取usb设备数量
3 打开第i个usb设备
4 获取usb设备的制造商id、设备名等信息
5 获取接口数
6 遍历接口，列出信息（端口类型，输入输出、最大包大小、最大burst、端口地址）
端口传输步骤(异步)
1 设置传输大小
2 设置overlapped
3 发送数据（数据地址，大小，overlapped地址）
4 等待传输结束
5 结束数据传输
/****0517********/
关于输入输出队列
当有新数据到来时，插入输入队列，
获取输入队列的最老节点，处理后，放入输出缓存
定时输出缓存中的一部分数据。
/***********0520***********/
去除了循环队列模式，套用了2018年6月的程序方法


